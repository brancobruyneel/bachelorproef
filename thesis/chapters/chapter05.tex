\chapter{Advies}

\section{Bruikbaarheid}

Een van de grote doelen in 2018 was voor de Rust community om een webtaal te worden. Door zich te
richten op WebAssembly, kan Rust nu ook worden uitgevoerd op het web net als JavaScript. Dit
betekent niet dat Rust Javascript volledig zal vervangen. Javascript biedt nog altijd meer voordelen
bij het bouwen van een web app. Dit is omdat JS een goede keuze is voor de meeste dingen. Het is
snel en gemakkelijk om aan de slag te gaan met JavaScript. Bovendien is er een levendig ecosysteem
vol met JavaScript ontwikkelaars die ongelooflijk innovatieve benaderingen hebben gecreÃ«erd voor
verschillende problemen op het web.

Nu in 2022 zijn er al een aantal tools die het makkelijk maken om Rust te gebruiken op het web. We
hebben \mintinline{rust}{webpack} en \mintinline{rust}{trunk} die voor ons de Rust code bundelt en
omzet naar wasm. Daarnaast kunnen we eenvoudig met javascript praten met behulp van
\mintinline{rust}{wasm-bindgen} en \mintinline{rust}{web-sys}. Toch is het nog verre van perfect.
Uiteindelijk willen we de browser API direct kunnen aanspreken vanuit WebAssembly. Een voorgestelde
oplossing waar nu aan wordt gewerkt is interface types \cite{wasm_interfaces}. Het probleem dat het
tracht op te lossen is het vertalen van waarden tussen verschillende types wanneer een module met
een andere module praat (of rechtstreeks met een host, zoals de browser). Want de huidige versie van
WebAssembly kan alleen maar met nummers praten. 

Wanneer WebAssembly dus niet met Javascript of de browser moet praten kan het dus profiteren van de
snelle prestaties die met een low level taal als Rust komt.

Buiten de browser kan Rust gewoon worden gebruikt in (micro) services voor het web waar prestaties
van cruciaal belang zijn. Het zal wat extra werk vereisen om 'correcte' en geheugen veilige code te
schrijven volgens de borrow checker, maar dit zal resulteren in extra prestaties en een robuust
systeem.

\clearpage

\section{Aanbevelingen}

Het onderzoek uit deze bachelorproef legde al een stevige basis voor het bouwen van een
webapplicatie. In de praktijk moeten er nog een aantal stappen ondernomen worden voor het resultaat
te gebruiken in productie.

Een eerste stap in de juiste richting, is het schrijven van testen. Zo voorkom je dat er
veelvoorkomende fouten terrecht komen in productie. Rust beschikt al over een ingebouwd systeem voor
het schrijven van testen met \mintinline{rust}{cargo test}. Optioneel kan je de crate
\mintinline{rust}{cargo-nextest} gebruiken. Het biedt wat meer functionaliteiten dan de ingebouwde
test runner, zoals een mooiere user interface en is in sommige code bases tot 60\% sneller dan
\mintinline{rust}{cargo test}.

Het technisch onderzoek in deze bachelorproef was een klein en simpel project. Bij grotere code
bases mag je met Rust lange compilatie tijden verwachten. Daarom is het best op plaatsen waar we
moeten compileren, zoveel mogelijk proberen om niet elke keer vanaf nul te compileren. Een mogelijke
oplossing hiervoor is cachen.

Om de API te kunnen deployen naar de cloud is er in het technischonderzoek een Docker container
gebruikt. Hier wil je dus vermijden dat je terug vanaf nul gaat compileren bij het aanpassen van je
code. Ontmoet \mintinline{rust}{cargo-chef}, een cargo-subcommando gemaakt om Rust docker builds te
versnelling met behulp van Docker layer caching. Met \mintinline{rust}{cargo-chef} krijg je tot 5x
snellere build times.

In sectie \ref{frameworks} is het Axum framework vermeld, wat een interessant framework is om naar
uit te kijken. Met dat Tokio zon'n populair async framework is en Axum deel uitmaakt van het
project, zou het een optie kunnen zijn om Actix-web te vervangen door Axum. 

Een laatste stap kan het optimaliseren van de wasm code zijn. Er zijn verschillende technieken
hiervoor om je wasm zo klein mogelijk te krijgen. Tijdens het onderzoek is hier niet verder op in
gegaan maar als we naar de code voorbeelden kijken van Yew, zien we dat zij hun wasm groottes hebben
kunnen verkleinen naar $\sim$100kB. \cite{wasm_size}
